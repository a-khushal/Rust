By default, Rust has a set of items defined in the standard library that it brings into the scope of every program. This set is called the prelude
In Rust, variables are immutable by default, meaning once we give the variable a value, the value won‚Äôt change. To make a variable mutable, we add mut before the variable name: let apples = 5; // immutable let mut bananas = 5; // mutable
The :: syntax in the ::new line indicates that new is an associated function of the String type. An associated function is a function that‚Äôs implemented on a type, in this case String. This new function creates a new, empty string.
if use std:io not used the we write std::io::stdin
The full job of read_line is to take whatever the user types into standard input and append that into a string (without overwriting its contents), so we therefore pass that string as an argument. The string argument needs to be mutable so the method can change the string‚Äôs content.
read_line puts whatever the user enters into the string we pass to it, but it also returns a Result value. Result is an enumeration, often called an enum, which is a type that can be in one of multiple possible states. We call each possible state a variant. Result‚Äôs variants are Ok and Err. The Ok variant indicates the operation was successful, and inside Ok is the successfully generated value. The Err variant means the operation failed, and Err contains information about how or why the operation failed.
The specifier 0.8.5 is actually shorthand for ^0.8.5, which means any version that is at least 0.8.5 but below 0.9.0.
Note: You won‚Äôt just know which traits to use and which methods and functions to call from a crate, so each crate has documentation with instructions for using it. Another neat feature of Cargo is that running the cargo doc --open command will build documentation provided by all your dependencies locally and open it in your browser. If you‚Äôre interested in other functionality in the rand crate, for example, run cargo doc --open and click rand in the sidebar on the left.
The Ordering type is another enum and has the variants Less, Greater, and Equal. These are the three outcomes that are possible when you compare two values.
Rust has a strong, static type system. However, it also has type inference.
i32, a 32-bit number; u32, an unsigned 32-bit number; i64, a 64-bit number;
Unless otherwise specified, Rust defaults to an i32, which is the type of secretNum
Rust allows us to shadow the previous value of guess with a new one. Shadowing lets us reuse the guess variable name rather than forcing us to create two unique variables, such as guess_str and guess.
The trim method on a String instance will eliminate any whitespace at the beginning and end. The user must press enter to satisfy read_line and input their guess, which adds a newline character to the string. For example, if the user types 5 and presses enter, guess looks like this: 5\n. The \n represents ‚Äúnewline.‚Äù (On Windows, pressing enter results in a carriage return and a newline, \r\n.) The trim method eliminates \n or \r\n, resulting in just 5.
The parse method on strings converts a string to another type. Here, we use it to convert from a string to a number. We need to tell Rust the exact number type we want by using let guess: u32. The colon (:) after guess tells Rust we‚Äôll annotate the variable‚Äôs type
The parse method will only work on characters that can logically be converted into numbers and so can easily cause errors. If, for example, the string contained Aüëç%, there would be no way to convert that to a number. hence we use expect() method at the end.
Err(_): The underscore, _, is a catchall value; in this example, we‚Äôre saying we want to match all Err values, no matter what information they have inside them.